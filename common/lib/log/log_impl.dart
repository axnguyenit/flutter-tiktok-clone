import 'package:flutter/material.dart';

import 'log.dart';

class LogImpl implements Log {
  static final LogImpl _singleton = LogImpl._internal();

  final topLeftCorner = '┌';
  final topRightCorner = '┐';
  final bottomLeftCorner = '└';
  final bottomRightCorner = '┘';
  final middleLeftCorner = '├';
  final middleRightCorner = '┤';
  final verticalLine = '│';
  final doubleDivider = '─';
  final lineLength = 100;

  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example:
  /// #0      LogImpl._log (package:common/log/log_impl.dart:86:37)
  static final _deviceStackTraceRegex =
      RegExp(r'#[0-9]+[\s]+(.+) \(([^\s]+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example:
  /// dart-sdk/lib/_internal/js_dev_runtime/patch/core_patch.dart 963:28
  /// ../dart-sdk/lib/_internal/js_dev_runtime/patch/core_patch.dart 963:28
  static final _webStackTraceRegex = RegExp(r'^([[.]+\/]?)?dart-sdk\/[^\s]+\/');

  /// ANSI Control Sequence Introducer, signals the terminal for new settings.
  static const ansiEsc = '\x1B[';

  /// Reset all colors and options for current SGRs to terminal defaults.
  static const ansiDefault = '${ansiEsc}0m';

  factory LogImpl() {
    return _singleton;
  }

  LogImpl._internal();

  @override
  void debug(String message, {List<String> messages = const []}) {
    _log(message, messages);
  }

  @override
  void info(String message, {List<String> messages = const []}) {
    _log(message, messages, 12);
  }

  @override
  void trace(String message, {List<String> messages = const []}) {
    _log(message, messages, (232 + (0.5.clamp(0.0, 1.0) * 23).round()));
  }

  @override
  void warning(String message, {List<String> messages = const []}) {
    _log(message, messages, 208);
  }

  @override
  void error(String message, {List<String> messages = const []}) {
    _log(message, messages, 196);
  }

  @override
  void fatal(String message, {List<String> messages = const []}) {
    _log(message, messages, 199);
  }

  bool _discardDeviceStacktraceLine(String line) {
    // current file path
    if (line.startsWith('packages/common/log/log_impl')) {
      return true;
    }

    final match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }

    return match.group(1)!.startsWith('LogImpl'); // current class name
  }

  void _log(
    String message, [
    List<String> messages = const [],
    int? fg,
  ]) {
    final doubleDividerLine = StringBuffer();
    final singleDividerLine = StringBuffer();

    for (int i = 0; i < lineLength - 2; i++) {
      doubleDividerLine.write(doubleDivider);
      singleDividerLine.write(doubleDivider);
    }

    final topBorder = '$topLeftCorner$doubleDividerLine$topRightCorner';
    final middleBorder =
        '$middleLeftCorner$singleDividerLine$middleRightCorner';
    final bottomBorder =
        '$bottomLeftCorner$doubleDividerLine$bottomRightCorner';
    List<String> lines = StackTrace.current.toString().split('\n');
    lines = lines.sublist(2);

    debugPrint(_wrapColorMessage(topBorder, fg));

    for (int i = 0; i < lines.length; i++) {
      if (_discardDeviceStacktraceLine(lines[i]) ||
          _webStackTraceRegex.hasMatch(lines[i]) ||
          lines[i].isEmpty) {
        continue;
      }
      debugPrint(_wrapColorMessage(
        '$verticalLine ${lines[i].replaceFirst(
              RegExp(r'#\d+\s+'),
              '',
            ).split('/').last.split(')').first}',
        fg,
      ));

      break;
    }

    debugPrint(_wrapColorMessage(middleBorder, fg));
    debugPrint(_wrapColorMessage('$verticalLine $message', fg));
    for (var message in messages) {
      debugPrint(_wrapColorMessage('$verticalLine $message', fg));
    }
    debugPrint(_wrapColorMessage(bottomBorder, fg));
  }

  String _wrapColorMessage(dynamic message, [int? fg]) {
    if (fg == null) {
      return message;
    }
    return '${ansiEsc}38;5;${fg}m$message$ansiDefault';
  }
}
